This application uses python flask as the background. Flask was chosen due to familiarity and the ability to use SocketIO with it. SocketIO allows messages to be sent and received by different users. It was very difficult to initially get SocketIO running because it was incompatible with the version of FireFox downloaded at the time. Once the most basic chat application was running, the next place of difficulty was keeping a socket across multiple webpages, so that once a user is logged in, they keep the same socket until they logged out. This proved to not be possible, however, as most SocketIO applications have to be written as a single page web application because JavaScript does not remain constant over multiple pages. A single page web application did not make a lot of sense, however. To solve this problem, the decision was made that once a user logins, they connect and disconnect from a socket whenever a new webpage is loaded. This adds some slight overhead when keeping a list of currently active users because this list is then updaed much more often than it would if a user was connected to the same socket while they are logged in.  

Once the general chat feature, where users can send chats to all other users was implemented, the private chat function was implemented. A line of html was included in layout.html that is hidden from view but includes the current logged in user. Then, when a user tries to start a private chat, the username of the user they wish to chat with is sent to the backend and the destination is set to the name of the user they wish to chat with. In the case of a public chat, that name is an empty string. Then, when a user tries to send a message, the function that runs when socket emits "new message" determines whether to broadcast the message to all users or to create a room with just the two users in it by looking at the destination of the message. If the destination user, called "buddy" in the code, is not connected to the chat room, a warning is shown to the user that their "buddy" is not online. Styling was not the focus of this project, so the notifications section does not look very nice at the moment. 

Once a new message is sent, the message is stored in the database. The previous ten messages between users are shown on the screen, but the user has the option of viewing their entire transcript if they wish. 

Users can also view other all other users profiles. This is done in a similar method as sending a private message, where the user's username that the current user wishes to view is sent to the backend. The index page has a boolean to determine if the user is viewing their own profile or someone else's. All of the information that is shown on index.html is stored in the database. For the profile pictures, a string of the path to the image is stored in the database and all the images are stored in another directory. The difference only between viewing another user's profile and the user's own profile is that the user has the option to change their profile information if they choose. 

Overall, socket introduced a number of challenging errors, and often made it difficult to test, as multiple browsers would have to be open in order to chat with another user. The appearance of the application is not very proffessional, which would be a priority in continuing to work on this project. I am pleased with the overall functionality of the site, although if I were to go back, I would likely use meteor instead of flask because meteor applications are single page, which would be good for SocketIO. This was an interesting project and a learning experience, and I hope to be able to find the time to continue to work on the site in the future, as it has the potential to be something that could actually be used in the real world. 

